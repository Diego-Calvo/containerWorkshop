name: Deploy to Azure Container Apps

on:
  push:
    branches: [ dev ]
  workflow_dispatch:
    inputs:
      resourceGroupName:
        description: 'Resource Group Name'
        required: false
        default: 'containerWorkshop'
        type: string
      location:
        description: 'Azure Region'
        required: false
        default: 'eastus2'
        type: choice
        options:
          - eastus2
          - westus2
          - centralus
          - westeurope
          - northeurope
          - southeastasia
          - australiaeast
      environmentName:
        description: 'Container Apps Environment Name'
        required: false
        default: 'workshop-dev-env'
        type: string
      deployInfrastructure:
        description: 'Deploy Infrastructure (uncheck if already exists)'
        required: false
        default: true
        type: boolean
      deployApplications:
        description: 'Deploy Applications'
        required: false
        default: true
        type: boolean

env:
  # Use workflow inputs for manual deployment, or repository variables/defaults for automatic deployment
  RESOURCE_GROUP_NAME: ${{ github.event.inputs.resourceGroupName || vars.RESOURCE_GROUP_NAME || 'containerWorkshop' }}
  LOCATION: ${{ github.event.inputs.location || vars.AZURE_LOCATION || 'eastus2' }}
  ENVIRONMENT_NAME: ${{ github.event.inputs.environmentName || vars.ENVIRONMENT_NAME || 'workshop-dev-env' }}
  
  # Container Registry will be created dynamically
  CONTAINER_REGISTRY_NAME: ${{ vars.CONTAINER_REGISTRY_NAME || format('workshopacr{0}', github.run_number) }}
  
  # Application settings
  FRONTEND_APP_NAME: workshop-frontend-dev
  BACKEND_APP_NAME: workshop-backend-dev
  
  # Deployment flags (default to true for automatic deployments)
  DEPLOY_INFRASTRUCTURE: ${{ github.event.inputs.deployInfrastructure || 'true' }}
  DEPLOY_APPLICATIONS: ${{ github.event.inputs.deployApplications || 'true' }}

jobs:
  # Infrastructure deployment job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deployInfrastructure != 'false' }}
    outputs:
      containerRegistryName: ${{ steps.check-infrastructure.outputs.containerRegistryName || steps.deploy.outputs.containerRegistryName }}
      containerRegistryLoginServer: ${{ steps.check-infrastructure.outputs.containerRegistryLoginServer || steps.deploy.outputs.containerRegistryLoginServer }}
      environmentName: ${{ steps.check-infrastructure.outputs.environmentName || steps.deploy.outputs.environmentName }}
      infrastructureExists: ${{ steps.check-infrastructure.outputs.INFRASTRUCTURE_EXISTS }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Azure CLI Login
      run: |
        # Create temporary certificate file from secret (properly handle JSON escaping)
        cat > azure_creds.json << 'EOF'
        ${{ secrets.AZURE_CREDENTIALS }}
        EOF
        
        # Validate JSON format
        if ! jq empty azure_creds.json 2>/dev/null; then
          echo "Error: AZURE_CREDENTIALS secret contains invalid JSON"
          echo "Please ensure your secret follows this format:"
          echo '{"clientId":"...","clientCertificate":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----","subscriptionId":"...","tenantId":"..."}'
          exit 1
        fi
        
        # Extract certificate content and save to file
        jq -r '.clientCertificate' azure_creds.json > client_cert.pem
        
        # Extract other credentials
        CLIENT_ID=$(jq -r '.clientId' azure_creds.json)
        TENANT_ID=$(jq -r '.tenantId' azure_creds.json)
        SUBSCRIPTION_ID=$(jq -r '.subscriptionId' azure_creds.json)
        
        # Validate extracted values
        if [[ "$CLIENT_ID" == "null" || "$TENANT_ID" == "null" || "$SUBSCRIPTION_ID" == "null" ]]; then
          echo "Error: Missing required fields in AZURE_CREDENTIALS secret"
          exit 1
        fi
        
        # Login with certificate (using --certificate parameter, not --password)
        az login --service-principal \
          --username "$CLIENT_ID" \
          --tenant "$TENANT_ID" \
          --certificate client_cert.pem
        
        # Set default subscription
        az account set --subscription "$SUBSCRIPTION_ID"
        
        # Note: Keep certificate file for subsequent Azure CLI commands
        # Will be cleaned up at the end of the job
        rm -f azure_creds.json  # Remove credentials JSON but keep cert file
      shell: bash

    - name: Create Resource Group
      run: |
        # Check if resource group already exists
        echo "üîç Checking if resource group '${{ env.RESOURCE_GROUP_NAME }}' exists..."
        
        if az group show --name ${{ env.RESOURCE_GROUP_NAME }} --output none 2>/dev/null; then
          echo "‚úÖ Resource group '${{ env.RESOURCE_GROUP_NAME }}' already exists"
          echo "üìã Current resource group info:"
          az group show --name ${{ env.RESOURCE_GROUP_NAME }} --output table
        else
          echo "üöÄ Creating resource group '${{ env.RESOURCE_GROUP_NAME }}'..."
          az group create \
            --name ${{ env.RESOURCE_GROUP_NAME }} \
            --location ${{ env.LOCATION }} \
            --tags \
              "Environment=Development" \
              "Project=ContainerWorkshop" \
              "DeployedBy=GitHubActions" \
              "Branch=${{ github.ref_name }}"
          echo "‚úÖ Resource group created successfully"
        fi

    - name: Check Existing Infrastructure
      id: check-infrastructure
      run: |
        # Check if key infrastructure components already exist
        echo "üîç Checking existing infrastructure components..."
        
        # Check for Container Apps Environment
        EXISTING_ENV=$(az containerapp env list \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query "[?name=='${{ env.ENVIRONMENT_NAME }}'].name" \
          --output tsv 2>/dev/null || echo "")
        
        # Check for Container Registry
        EXISTING_ACR=$(az acr list \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query "[?name=='${{ env.CONTAINER_REGISTRY_NAME }}'].name" \
          --output tsv 2>/dev/null || echo "")
        
        if [[ -n "$EXISTING_ENV" && -n "$EXISTING_ACR" ]]; then
          echo "‚úÖ Infrastructure already exists:"
          echo "  ‚Ä¢ Container Apps Environment: $EXISTING_ENV"
          echo "  ‚Ä¢ Container Registry: $EXISTING_ACR"
          echo "üîÑ Will skip infrastructure deployment and use existing resources"
          echo "INFRASTRUCTURE_EXISTS=true" >> $GITHUB_OUTPUT
          
          # Get existing infrastructure info for next job
          REGISTRY_LOGIN_SERVER=$(az acr show \
            --name ${{ env.CONTAINER_REGISTRY_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --query "loginServer" \
            --output tsv)
          
          echo "containerRegistryName=${{ env.CONTAINER_REGISTRY_NAME }}" >> $GITHUB_OUTPUT
          echo "containerRegistryLoginServer=$REGISTRY_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "environmentName=${{ env.ENVIRONMENT_NAME }}" >> $GITHUB_OUTPUT
        else
          echo "üöÄ Infrastructure needs to be deployed"
          echo "INFRASTRUCTURE_EXISTS=false" >> $GITHUB_OUTPUT
        fi

    - name: Deploy Infrastructure
      id: deploy
      if: steps.check-infrastructure.outputs.INFRASTRUCTURE_EXISTS == 'false'
      run: |
        # Try Azure PowerShell approach as Azure CLI seems to have stream issues
        echo "üöÄ Starting infrastructure deployment with alternative approach..."
        DEPLOYMENT_NAME="infrastructure-deployment-$(date +%s)"
        echo "üìù Deployment name: $DEPLOYMENT_NAME"
        
        # Install Azure PowerShell if not available
        echo "ÔøΩ Setting up Azure PowerShell..."
        if ! command -v pwsh &> /dev/null; then
          echo "Installing PowerShell..."
          wget -q https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
          sudo dpkg -i packages-microsoft-prod.deb
          sudo apt-get update
          sudo apt-get install -y powershell
        fi
        
        # Try deployment using Azure PowerShell
        echo "üîÑ Attempting deployment with Azure PowerShell..."
        pwsh -Command "
          Install-Module -Name Az -Force -Scope CurrentUser -Repository PSGallery -AllowClobber
          Import-Module Az
          
          # Login using service principal
          \$clientId = '$CLIENT_ID'
          \$tenantId = '$TENANT_ID'
          \$subscriptionId = '$SUBSCRIPTION_ID'
          \$certPath = 'client_cert.pem'
          
          # Connect to Azure
          Connect-AzAccount -ServicePrincipal -ApplicationId \$clientId -TenantId \$tenantId -CertificateThumbprint \$certPath -Subscription \$subscriptionId
          
          # Deploy template
          New-AzResourceGroupDeployment -ResourceGroupName '${{ env.RESOURCE_GROUP_NAME }}' -TemplateFile 'infrastructure/bicep/main.bicep' -Name '$DEPLOYMENT_NAME' -environmentName '${{ env.ENVIRONMENT_NAME }}' -location '${{ env.LOCATION }}' -namePrefix 'workshop' -containerRegistryName '${{ env.CONTAINER_REGISTRY_NAME }}'
        "
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ PowerShell deployment completed successfully"
        else
          echo "‚ùå PowerShell deployment failed, trying simplified Azure CLI approach..."
          
          # Fallback: Try creating resources individually
          echo "üîÑ Creating resources individually..."
          
          # Create Container Registry
          echo "ÔøΩ Creating Container Registry..."
          az acr create \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --name ${{ env.CONTAINER_REGISTRY_NAME }} \
            --sku Standard \
            --admin-enabled true \
            --location ${{ env.LOCATION }} \
            --output none || echo "Registry creation failed or already exists"
          
          # Create Log Analytics Workspace
          echo "ÔøΩ Creating Log Analytics Workspace..."
          az monitor log-analytics workspace create \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --workspace-name workshop-logs \
            --location ${{ env.LOCATION }} \
            --output none || echo "Log Analytics creation failed or already exists"
          
          # Get Log Analytics Workspace ID
          LOG_ANALYTICS_ID=$(az monitor log-analytics workspace show \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --workspace-name workshop-logs \
            --query "customerId" \
            --output tsv 2>/dev/null || echo "")
          
          LOG_ANALYTICS_KEY=$(az monitor log-analytics workspace get-shared-keys \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --workspace-name workshop-logs \
            --query "primarySharedKey" \
            --output tsv 2>/dev/null || echo "")
          
          # Create Container Apps Environment
          echo "üèóÔ∏è Creating Container Apps Environment..."
          if [[ -n "$LOG_ANALYTICS_ID" && -n "$LOG_ANALYTICS_KEY" ]]; then
            az containerapp env create \
              --name ${{ env.ENVIRONMENT_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
              --location ${{ env.LOCATION }} \
              --logs-workspace-id "$LOG_ANALYTICS_ID" \
              --logs-workspace-key "$LOG_ANALYTICS_KEY" \
              --output none || echo "Container Apps Environment creation failed or already exists"
          else
            az containerapp env create \
              --name ${{ env.ENVIRONMENT_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
              --location ${{ env.LOCATION }} \
              --output none || echo "Container Apps Environment creation failed or already exists"
          fi
          
          # Create Cosmos DB (optional for workshop)
          echo "ÔøΩ Creating Cosmos DB..."
          az cosmosdb create \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --name workshop-cosmos-${{ github.run_number }} \
            --locations regionName=${{ env.LOCATION }} \
            --default-consistency-level Session \
            --enable-free-tier true \
            --output none || echo "Cosmos DB creation failed or already exists"
        fi
        
        # Wait for resources to be available
        echo "‚è≥ Waiting for resources to be fully registered..."
        sleep 20
        
        echo "üìä Getting outputs from deployed resources..."
        
        # Get container registry info directly from Azure
        echo "üîç Querying Container Registry..."
        REGISTRY_NAME="${{ env.CONTAINER_REGISTRY_NAME }}"
        REGISTRY_LOGIN_SERVER=""
        
        # Try to get registry login server with retries
        for i in {1..15}; do
          echo "  Attempt $i/15..."
          REGISTRY_LOGIN_SERVER=$(az acr show \
            --name "$REGISTRY_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --query "loginServer" \
            --output tsv 2>/dev/null || echo "")
          
          if [[ -n "$REGISTRY_LOGIN_SERVER" ]]; then
            echo "  ‚úÖ Found registry: $REGISTRY_LOGIN_SERVER"
            break
          fi
          sleep 4
        done
        
        # Get container apps environment info
        echo "üîç Querying Container Apps Environment..."
        ENV_NAME=""
        
        # Try to get environment with retries
        for i in {1..15}; do
          echo "  Attempt $i/15..."
          ENV_NAME=$(az containerapp env show \
            --name "${{ env.ENVIRONMENT_NAME }}" \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --query "name" \
            --output tsv 2>/dev/null || echo "")
          
          if [[ -n "$ENV_NAME" ]]; then
            echo "  ‚úÖ Found environment: $ENV_NAME"
            break
          fi
          sleep 4
        done
        
        # Final validation
        echo "üîç Final validation:"
        echo "  Registry Name: $REGISTRY_NAME"
        echo "  Login Server: $REGISTRY_LOGIN_SERVER" 
        echo "  Environment: $ENV_NAME"
        
        if [[ -z "$REGISTRY_LOGIN_SERVER" || -z "$ENV_NAME" ]]; then
          echo "‚ùå Error: Could not retrieve all required resource information"
          echo "  Registry Login Server: '$REGISTRY_LOGIN_SERVER'"
          echo "  Environment Name: '$ENV_NAME'"
          
          # List all resources to see what was created
          echo "üîç Listing all resources in resource group..."
          az resource list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --output table || echo "Could not list resources"
          
          exit 1
        fi
        
        # Set outputs for next job
        echo "containerRegistryName=$REGISTRY_NAME" >> $GITHUB_OUTPUT
        echo "containerRegistryLoginServer=$REGISTRY_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "environmentName=$ENV_NAME" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Infrastructure deployed successfully"
        echo "üì¶ Container Registry: $REGISTRY_NAME"
        echo "üåê Login Server: $REGISTRY_LOGIN_SERVER"
        echo "üèóÔ∏è Environment: $ENV_NAME"
      shell: bash
      env:
        CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        RESOURCE_GROUP_NAME: ${{ env.RESOURCE_GROUP_NAME }}
        LOCATION: ${{ env.LOCATION }}
        ENVIRONMENT_NAME: ${{ env.ENVIRONMENT_NAME }}
        CONTAINER_REGISTRY_NAME: ${{ env.CONTAINER_REGISTRY_NAME }}

    - name: Cleanup Certificate Files
      if: always()
      run: |
        # Clean up certificate files at the end of the job
        rm -f client_cert.pem azure_creds.json
      shell: bash

  # Application deployment job
  deploy-applications:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deployApplications != 'false' }}
    needs: deploy-infrastructure
    # Continue even if infrastructure deployment was skipped
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Azure CLI Login
      run: |
        # Create temporary certificate file from secret (properly handle JSON escaping)
        cat > azure_creds.json << 'EOF'
        ${{ secrets.AZURE_CREDENTIALS }}
        EOF
        
        # Validate JSON format
        if ! jq empty azure_creds.json 2>/dev/null; then
          echo "Error: AZURE_CREDENTIALS secret contains invalid JSON"
          echo "Please ensure your secret follows this format:"
          echo '{"clientId":"...","clientCertificate":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----","subscriptionId":"...","tenantId":"..."}'
          exit 1
        fi
        
        # Extract certificate content and save to file
        jq -r '.clientCertificate' azure_creds.json > client_cert.pem
        
        # Extract other credentials
        CLIENT_ID=$(jq -r '.clientId' azure_creds.json)
        TENANT_ID=$(jq -r '.tenantId' azure_creds.json)
        SUBSCRIPTION_ID=$(jq -r '.subscriptionId' azure_creds.json)
        
        # Validate extracted values
        if [[ "$CLIENT_ID" == "null" || "$TENANT_ID" == "null" || "$SUBSCRIPTION_ID" == "null" ]]; then
          echo "Error: Missing required fields in AZURE_CREDENTIALS secret"
          exit 1
        fi
        
        # Login with certificate (using --certificate parameter, not --password)
        az login --service-principal \
          --username "$CLIENT_ID" \
          --tenant "$TENANT_ID" \
          --certificate client_cert.pem
        
        # Set default subscription
        az account set --subscription "$SUBSCRIPTION_ID"
        
        # Note: Keep certificate file for subsequent Azure CLI commands
        # Will be cleaned up at the end of the job
        rm -f azure_creds.json  # Remove credentials JSON but keep cert file
      shell: bash

    - name: Get Existing Infrastructure Info
      id: get-existing
      if: ${{ github.event.inputs.deployInfrastructure == 'false' || needs.deploy-infrastructure.result == 'skipped' }}
      run: |
        # Get existing container registry
        REGISTRY_INFO=$(az acr list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query '[0]' --output json)
        REGISTRY_NAME=$(echo $REGISTRY_INFO | jq -r '.name')
        REGISTRY_LOGIN_SERVER=$(echo $REGISTRY_INFO | jq -r '.loginServer')
        
        # Get existing environment
        ENV_INFO=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query '[0]' --output json)
        ENV_NAME=$(echo $ENV_INFO | jq -r '.name')
        
        # Set outputs
        echo "containerRegistryName=$REGISTRY_NAME" >> $GITHUB_OUTPUT
        echo "containerRegistryLoginServer=$REGISTRY_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "environmentName=$ENV_NAME" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Found existing infrastructure"
        echo "üì¶ Container Registry: $REGISTRY_NAME"
        echo "üåê Login Server: $REGISTRY_LOGIN_SERVER"
        echo "üèóÔ∏è Environment: $ENV_NAME"

    - name: Login to Container Registry
      run: |
        # Get registry name from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_NAME="${{ needs.deploy-infrastructure.outputs.containerRegistryName }}"
        else
          REGISTRY_NAME="${{ steps.get-existing.outputs.containerRegistryName }}"
        fi
        
        az acr login --name $REGISTRY_NAME

    - name: Build and Push Frontend Container
      run: |
        # Get registry server from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        # Build frontend image
        docker build -t $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG \
                     -t $REGISTRY_SERVER/workshop-frontend:latest \
                     ./frontend
        
        # Push images
        docker push $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG
        docker push $REGISTRY_SERVER/workshop-frontend:latest
        
        echo "‚úÖ Frontend image pushed: $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG"

    - name: Build and Push Backend Container
      run: |
        # Get registry server from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        # Build backend image
        docker build -t $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG \
                     -t $REGISTRY_SERVER/workshop-backend:latest \
                     ./backend
        
        # Push images
        docker push $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG
        docker push $REGISTRY_SERVER/workshop-backend:latest
        
        echo "‚úÖ Backend image pushed: $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG"

    - name: Deploy Backend Container App
      run: |
        # Get registry server and environment from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ needs.deploy-infrastructure.outputs.environmentName }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ steps.get-existing.outputs.environmentName }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        az containerapp create \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --environment $ENV_NAME \
          --image $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG \
          --registry-server $REGISTRY_SERVER \
          --target-port 3001 \
          --ingress external \
          --min-replicas 1 \
          --max-replicas 3 \
          --cpu 0.5 \
          --memory 1Gi \
          --enable-dapr \
          --dapr-app-id workshop-api \
          --dapr-app-port 3001 \
          --env-vars \
            "NODE_ENV=production" \
            "DAPR_ENABLED=true" \
            "PORT=3001" \
          --tags \
            "Environment=Development" \
            "Application=Backend" \
            "Version=$IMAGE_TAG"
        
        # Get backend URL
        BACKEND_URL=$(az containerapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "‚úÖ Backend deployed: https://$BACKEND_URL"
        echo "BACKEND_URL=https://$BACKEND_URL" >> $GITHUB_ENV

    - name: Deploy Frontend Container App
      run: |
        # Get registry server and environment from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ needs.deploy-infrastructure.outputs.environmentName }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ steps.get-existing.outputs.environmentName }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        az containerapp create \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --environment $ENV_NAME \
          --image $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG \
          --registry-server $REGISTRY_SERVER \
          --target-port 80 \
          --ingress external \
          --min-replicas 1 \
          --max-replicas 3 \
          --cpu 0.25 \
          --memory 0.5Gi \
          --env-vars \
            "REACT_APP_API_URL=$BACKEND_URL" \
            "NODE_ENV=production" \
          --tags \
            "Environment=Development" \
            "Application=Frontend" \
            "Version=$IMAGE_TAG"
        
        # Get frontend URL
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "‚úÖ Frontend deployed: https://$FRONTEND_URL"

    - name: Update Backend CORS Settings
      run: |
        # Update backend with frontend URL for CORS
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        az containerapp update \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --set-env-vars \
            "CORS_ORIGIN=https://$FRONTEND_URL" \
            "NODE_ENV=production" \
            "DAPR_ENABLED=true" \
            "PORT=3001"
        
        echo "‚úÖ Backend CORS updated for frontend: https://$FRONTEND_URL"

    - name: Deployment Summary
      run: |
        echo "üéâ Deployment completed successfully!"
        echo ""
        echo "üìã Deployment Details:"
        echo "  ‚Ä¢ Resource Group: ${{ env.RESOURCE_GROUP_NAME }}"
        echo "  ‚Ä¢ Environment: ${{ needs.deploy-infrastructure.outputs.environmentName }}"
        echo "  ‚Ä¢ Location: ${{ env.LOCATION }}"
        echo "  ‚Ä¢ Registry: ${{ needs.deploy-infrastructure.outputs.containerRegistryName }}"
        echo ""
        echo "üåê Application URLs:"
        
        # Get final URLs
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        BACKEND_URL=$(az containerapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "  ‚Ä¢ Frontend: https://$FRONTEND_URL"
        echo "  ‚Ä¢ Backend:  https://$BACKEND_URL"
        echo "  ‚Ä¢ Backend Health: https://$BACKEND_URL/health"
        echo ""
        echo "üîß Next Steps:"
        echo "  1. Test the application endpoints"
        echo "  2. Check container logs if needed"
        echo "  3. Monitor application performance"

    - name: Cleanup Certificate Files
      if: always()
      run: |
        # Clean up certificate files at the end of the job
        rm -f client_cert.pem azure_creds.json
      shell: bash
