name: Deploy to Azure Container Apps

on:
  push:
    branches: [ dev ]
  workflow_dispatch:
    inputs:
      resourceGroupName:
        description: 'Resource Group Name'
        required: false
        default: 'containerWorkshop'
        type: string
      location:
        description: 'Azure Region'
        required: false
        default: 'eastus2'
        type: choice
        options:
          - eastus2
          - westus2
          - centralus
          - westeurope
          - northeurope
          - southeastasia
          - australiaeast
      environmentName:
        description: 'Container Apps Environment Name'
        required: false
        default: 'workshop-dev-env'
        type: string
      deployInfrastructure:
        description: 'Deploy Infrastructure (uncheck if already exists)'
        required: false
        default: true
        type: boolean
      deployApplications:
        description: 'Deploy Applications'
        required: false
        default: true
        type: boolean

env:
  # Use workflow inputs for manual deployment, or repository variables/defaults for automatic deployment
  RESOURCE_GROUP_NAME: ${{ github.event.inputs.resourceGroupName || vars.RESOURCE_GROUP_NAME || 'containerWorkshop' }}
  LOCATION: ${{ github.event.inputs.location || vars.AZURE_LOCATION || 'eastus2' }}
  ENVIRONMENT_NAME: ${{ github.event.inputs.environmentName || vars.ENVIRONMENT_NAME || 'workshop-dev-env' }}
  
  # Container Registry will be created dynamically
  CONTAINER_REGISTRY_NAME: ${{ vars.CONTAINER_REGISTRY_NAME || format('workshopacr{0}', github.run_number) }}
  
  # Application settings
  FRONTEND_APP_NAME: workshop-frontend-dev
  BACKEND_APP_NAME: workshop-backend-dev
  
  # Deployment flags (default to true for automatic deployments)
  DEPLOY_INFRASTRUCTURE: ${{ github.event.inputs.deployInfrastructure || 'true' }}
  DEPLOY_APPLICATIONS: ${{ github.event.inputs.deployApplications || 'true' }}

jobs:
  # Infrastructure deployment job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deployInfrastructure != 'false' }}
    outputs:
      containerRegistryName: ${{ steps.deploy.outputs.containerRegistryName }}
      containerRegistryLoginServer: ${{ steps.deploy.outputs.containerRegistryLoginServer }}
      environmentName: ${{ steps.deploy.outputs.environmentName }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Azure CLI Login
      run: |
        # Create temporary certificate file from secret (properly handle JSON escaping)
        cat > azure_creds.json << 'EOF'
        ${{ secrets.AZURE_CREDENTIALS }}
        EOF
        
        # Validate JSON format
        if ! jq empty azure_creds.json 2>/dev/null; then
          echo "Error: AZURE_CREDENTIALS secret contains invalid JSON"
          echo "Please ensure your secret follows this format:"
          echo '{"clientId":"...","clientCertificate":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----","subscriptionId":"...","tenantId":"..."}'
          exit 1
        fi
        
        # Extract certificate content and save to file
        jq -r '.clientCertificate' azure_creds.json > client_cert.pem
        
        # Extract other credentials
        CLIENT_ID=$(jq -r '.clientId' azure_creds.json)
        TENANT_ID=$(jq -r '.tenantId' azure_creds.json)
        SUBSCRIPTION_ID=$(jq -r '.subscriptionId' azure_creds.json)
        
        # Validate extracted values
        if [[ "$CLIENT_ID" == "null" || "$TENANT_ID" == "null" || "$SUBSCRIPTION_ID" == "null" ]]; then
          echo "Error: Missing required fields in AZURE_CREDENTIALS secret"
          exit 1
        fi
        
        # Login with certificate
        az login --service-principal \
          --username "$CLIENT_ID" \
          --tenant "$TENANT_ID" \
          --password client_cert.pem
        
        # Set default subscription
        az account set --subscription "$SUBSCRIPTION_ID"
        
        # Clean up certificate file
        rm -f client_cert.pem azure_creds.json
      shell: bash

    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ env.RESOURCE_GROUP_NAME }} \
          --location ${{ env.LOCATION }} \
          --tags \
            "Environment=Development" \
            "Project=ContainerWorkshop" \
            "DeployedBy=GitHubActions" \
            "Branch=${{ github.ref_name }}"

    - name: Deploy Infrastructure
      id: deploy
      run: |
        # Deploy the Bicep template
        DEPLOYMENT_OUTPUT=$(az deployment group create \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --template-file infrastructure/bicep/main.bicep \
          --parameters \
            environmentName="${{ env.ENVIRONMENT_NAME }}" \
            location="${{ env.LOCATION }}" \
            namePrefix="workshop" \
            containerRegistryName="${{ env.CONTAINER_REGISTRY_NAME }}" \
          --query 'properties.outputs' \
          --output json)
        
        # Extract outputs
        REGISTRY_NAME=$(echo $DEPLOYMENT_OUTPUT | jq -r '.containerRegistryName.value')
        REGISTRY_LOGIN_SERVER=$(echo $DEPLOYMENT_OUTPUT | jq -r '.containerRegistryLoginServer.value')
        ENV_NAME=$(echo $DEPLOYMENT_OUTPUT | jq -r '.environmentName.value')
        
        # Set outputs for next job
        echo "containerRegistryName=$REGISTRY_NAME" >> $GITHUB_OUTPUT
        echo "containerRegistryLoginServer=$REGISTRY_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "environmentName=$ENV_NAME" >> $GITHUB_OUTPUT
        
        echo "✅ Infrastructure deployed successfully"
        echo "📦 Container Registry: $REGISTRY_NAME"
        echo "🌐 Login Server: $REGISTRY_LOGIN_SERVER"
        echo "🏗️ Environment: $ENV_NAME"

  # Application deployment job
  deploy-applications:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deployApplications != 'false' }}
    needs: deploy-infrastructure
    # Continue even if infrastructure deployment was skipped
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Azure CLI Login
      run: |
        # Create temporary certificate file from secret (properly handle JSON escaping)
        cat > azure_creds.json << 'EOF'
        ${{ secrets.AZURE_CREDENTIALS }}
        EOF
        
        # Validate JSON format
        if ! jq empty azure_creds.json 2>/dev/null; then
          echo "Error: AZURE_CREDENTIALS secret contains invalid JSON"
          echo "Please ensure your secret follows this format:"
          echo '{"clientId":"...","clientCertificate":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----","subscriptionId":"...","tenantId":"..."}'
          exit 1
        fi
        
        # Extract certificate content and save to file
        jq -r '.clientCertificate' azure_creds.json > client_cert.pem
        
        # Extract other credentials
        CLIENT_ID=$(jq -r '.clientId' azure_creds.json)
        TENANT_ID=$(jq -r '.tenantId' azure_creds.json)
        SUBSCRIPTION_ID=$(jq -r '.subscriptionId' azure_creds.json)
        
        # Validate extracted values
        if [[ "$CLIENT_ID" == "null" || "$TENANT_ID" == "null" || "$SUBSCRIPTION_ID" == "null" ]]; then
          echo "Error: Missing required fields in AZURE_CREDENTIALS secret"
          exit 1
        fi
        
        # Login with certificate
        az login --service-principal \
          --username "$CLIENT_ID" \
          --tenant "$TENANT_ID" \
          --password client_cert.pem
        
        # Set default subscription
        az account set --subscription "$SUBSCRIPTION_ID"
        
        # Clean up certificate file
        rm -f client_cert.pem azure_creds.json
      shell: bash

    - name: Get Existing Infrastructure Info
      id: get-existing
      if: ${{ github.event.inputs.deployInfrastructure == 'false' || needs.deploy-infrastructure.result == 'skipped' }}
      run: |
        # Get existing container registry
        REGISTRY_INFO=$(az acr list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query '[0]' --output json)
        REGISTRY_NAME=$(echo $REGISTRY_INFO | jq -r '.name')
        REGISTRY_LOGIN_SERVER=$(echo $REGISTRY_INFO | jq -r '.loginServer')
        
        # Get existing environment
        ENV_INFO=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query '[0]' --output json)
        ENV_NAME=$(echo $ENV_INFO | jq -r '.name')
        
        # Set outputs
        echo "containerRegistryName=$REGISTRY_NAME" >> $GITHUB_OUTPUT
        echo "containerRegistryLoginServer=$REGISTRY_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "environmentName=$ENV_NAME" >> $GITHUB_OUTPUT
        
        echo "✅ Found existing infrastructure"
        echo "📦 Container Registry: $REGISTRY_NAME"
        echo "🌐 Login Server: $REGISTRY_LOGIN_SERVER"
        echo "🏗️ Environment: $ENV_NAME"

    - name: Login to Container Registry
      run: |
        # Get registry name from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_NAME="${{ needs.deploy-infrastructure.outputs.containerRegistryName }}"
        else
          REGISTRY_NAME="${{ steps.get-existing.outputs.containerRegistryName }}"
        fi
        
        az acr login --name $REGISTRY_NAME

    - name: Build and Push Frontend Container
      run: |
        # Get registry server from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        # Build frontend image
        docker build -t $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG \
                     -t $REGISTRY_SERVER/workshop-frontend:latest \
                     ./frontend
        
        # Push images
        docker push $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG
        docker push $REGISTRY_SERVER/workshop-frontend:latest
        
        echo "✅ Frontend image pushed: $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG"

    - name: Build and Push Backend Container
      run: |
        # Get registry server from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        # Build backend image
        docker build -t $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG \
                     -t $REGISTRY_SERVER/workshop-backend:latest \
                     ./backend
        
        # Push images
        docker push $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG
        docker push $REGISTRY_SERVER/workshop-backend:latest
        
        echo "✅ Backend image pushed: $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG"

    - name: Deploy Backend Container App
      run: |
        # Get registry server and environment from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ needs.deploy-infrastructure.outputs.environmentName }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ steps.get-existing.outputs.environmentName }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        az containerapp create \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --environment $ENV_NAME \
          --image $REGISTRY_SERVER/workshop-backend:$IMAGE_TAG \
          --registry-server $REGISTRY_SERVER \
          --target-port 3001 \
          --ingress external \
          --min-replicas 1 \
          --max-replicas 3 \
          --cpu 0.5 \
          --memory 1Gi \
          --enable-dapr \
          --dapr-app-id workshop-api \
          --dapr-app-port 3001 \
          --env-vars \
            "NODE_ENV=production" \
            "DAPR_ENABLED=true" \
            "PORT=3001" \
          --tags \
            "Environment=Development" \
            "Application=Backend" \
            "Version=$IMAGE_TAG"
        
        # Get backend URL
        BACKEND_URL=$(az containerapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "✅ Backend deployed: https://$BACKEND_URL"
        echo "BACKEND_URL=https://$BACKEND_URL" >> $GITHUB_ENV

    - name: Deploy Frontend Container App
      run: |
        # Get registry server and environment from either infrastructure deployment or existing infrastructure
        if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
          REGISTRY_SERVER="${{ needs.deploy-infrastructure.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ needs.deploy-infrastructure.outputs.environmentName }}"
        else
          REGISTRY_SERVER="${{ steps.get-existing.outputs.containerRegistryLoginServer }}"
          ENV_NAME="${{ steps.get-existing.outputs.environmentName }}"
        fi
        
        IMAGE_TAG="dev-${{ github.sha }}"
        
        az containerapp create \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --environment $ENV_NAME \
          --image $REGISTRY_SERVER/workshop-frontend:$IMAGE_TAG \
          --registry-server $REGISTRY_SERVER \
          --target-port 80 \
          --ingress external \
          --min-replicas 1 \
          --max-replicas 3 \
          --cpu 0.25 \
          --memory 0.5Gi \
          --env-vars \
            "REACT_APP_API_URL=$BACKEND_URL" \
            "NODE_ENV=production" \
          --tags \
            "Environment=Development" \
            "Application=Frontend" \
            "Version=$IMAGE_TAG"
        
        # Get frontend URL
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "✅ Frontend deployed: https://$FRONTEND_URL"

    - name: Update Backend CORS Settings
      run: |
        # Update backend with frontend URL for CORS
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        az containerapp update \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --set-env-vars \
            "CORS_ORIGIN=https://$FRONTEND_URL" \
            "NODE_ENV=production" \
            "DAPR_ENABLED=true" \
            "PORT=3001"
        
        echo "✅ Backend CORS updated for frontend: https://$FRONTEND_URL"

    - name: Deployment Summary
      run: |
        echo "🎉 Deployment completed successfully!"
        echo ""
        echo "📋 Deployment Details:"
        echo "  • Resource Group: ${{ env.RESOURCE_GROUP_NAME }}"
        echo "  • Environment: ${{ needs.deploy-infrastructure.outputs.environmentName }}"
        echo "  • Location: ${{ env.LOCATION }}"
        echo "  • Registry: ${{ needs.deploy-infrastructure.outputs.containerRegistryName }}"
        echo ""
        echo "🌐 Application URLs:"
        
        # Get final URLs
        FRONTEND_URL=$(az containerapp show \
          --name ${{ env.FRONTEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        BACKEND_URL=$(az containerapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query 'properties.configuration.ingress.fqdn' \
          --output tsv)
        
        echo "  • Frontend: https://$FRONTEND_URL"
        echo "  • Backend:  https://$BACKEND_URL"
        echo "  • Backend Health: https://$BACKEND_URL/health"
        echo ""
        echo "🔧 Next Steps:"
        echo "  1. Test the application endpoints"
        echo "  2. Check container logs if needed"
        echo "  3. Monitor application performance"
